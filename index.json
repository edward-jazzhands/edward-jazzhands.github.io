[{"content":"","externalUrl":"https://www.github.com/edward-jazzhands/textual-coloromatic","permalink":"/textual-libraries/textual-coloromatic/","section":"Textual Libraries","summary":"A widget for Textual that makes it easy to display ASCII art with color effects and animations.","title":"Textual-Color-O-Matic","type":"textual-libraries"},{"content":"","externalUrl":"https://www.github.com/edward-jazzhands/textual-pyfiglet","permalink":"/textual-libraries/textual-pyfiglet/","section":"Textual Libraries","summary":"A widget that fully integrates the famous FIGlet ASCII art generator into Textual.","title":"Textual-Pyfiglet","type":"textual-libraries"},{"content":"","externalUrl":"https://www.github.com/edward-jazzhands/textual-slidecontainer","permalink":"/textual-libraries/textual-slidecontainer/","section":"Textual Libraries","summary":"Provides a new container, the \u003ccode\u003eSlideContainer\u003c/code\u003e. Makes it easy to create sliding or hidden menu bars.","title":"Textual-SlideContainer","type":"textual-libraries"},{"content":"","externalUrl":"https://www.github.com/edward-jazzhands/textual-window","permalink":"/textual-libraries/textual-window/","section":"Textual Libraries","summary":"A Textual widget for a floating, draggable window and included window bar/manager system.","title":"Textual-Window","type":"textual-libraries"},{"content":" by Edward Jazzhands ","date":"6 August 2025","externalUrl":null,"permalink":"/posts/","section":"Articles","summary":"","title":"Articles","type":"posts"},{"content":"","date":"6 August 2025","externalUrl":null,"permalink":"/","section":"Edward Jazzhands","summary":"","title":"Edward Jazzhands","type":"page"},{"content":" In this post, you\u0026#39;ll learn how to: • Set up Nox for automated testing across Python versions\n• Integrate UV into Nox as the environment manager\n• Build a blazing-fast™ GitHub Actions CI pipeline\n• Avoid common mistakes when combining Nox and UV\nIf you have been following the world of Python tooling at all the past year, you\u0026rsquo;ve probably heard of UV. In fact there\u0026rsquo;s a good chance you\u0026rsquo;re already using it. If you\u0026rsquo;re not, I can only recommend looking into it. For those of you that are using UV already, I\u0026rsquo;m willing to bet that you\u0026rsquo;re not yet aware of the beautiful synergy that is created by the combination of UV with the Nox testing automation tool. This is a new combination that is not currently well documented. I thought I\u0026rsquo;d do my part to change that.\nWhat Makes Nox Different from Tox? # Nox is a Python testing automation tool that is similar to Tox. In case you\u0026rsquo;re not familiar, Nox and Tox are tools that allow you to automate testing in multiple Python environments. This is especially useful if you\u0026rsquo;re a library author and want to ensure that your code works across different versions of Python, or across different versions of your dependencies (ie. different versions of Django, Flask, etc). Tox has been around for a long time and is very popular. However, due to how Tox works, it is not easy to integrate with other package managers. Tox is limited to using the standard Python package manager (pip) to install dependencies, as well as the virtualenv library to create virtual environments. This means that if you want to bring your own package manager, or tool for creating virtual environments, you\u0026rsquo;re out of luck. Up until recently, this was not a problem for most people, as pip and venv were the de facto standards for Python package management and virtual environments. But with the meteoric rise of UV and all the clear advantages it brings, as well as the increasing popularity of Docker and containerization, the limitations of Tox are becoming more apparent.\nThis is where Nox comes in. Nox is a more modern tool that has first-class support for a variety of package managers and virtual environment tools: venv, uv, conda, mamba, micromamba, or virtualenv. You can use Nox to automate your testing regardless of which of these tools you prefer. Also, unlike Tox which uses a declarative configuration file (tox.ini), Nox uses a Python file (noxfile.py) to define your test sessions. This leverages the full power of Python to set up your tests, which can be very useful for more complex testing scenarios. If you already write a lot of Python, this will feel very natural to you.\nInstalling Nox with UV # Nox is meant to be installed as a global tool. Since Nox manages environments, you can\u0026rsquo;t install it as a dependency in your current environment. The official Nox documentation recommends installing it as a global tool using Pipx (The Tox documentation also recommends using either Pipx or UV).\nIf you\u0026rsquo;re familiar with UV then you\u0026rsquo;ll know that UV can also replace Pipx as your global tool manager. That is indeed very convenient for us, as it means we can simply install Nox using UV:\nuv tool install nox First-class UV support # Support for using different environment backends is possibly the most compelling feature that Nox brings to the table. With Tox, you are stuck with pip. This is very inconvenient if you\u0026rsquo;re already using UV to manage your project\u0026rsquo;s dependencies because pip and UV do not share a cache. If you are using Tox together with UV, then you will have to download all of your dependencies again and store them all in a separate cache. This is not only inefficient, it also slows down your testing process. With Nox, you can use UV as your environment backend, which means that you can use the same cache for both your local development and your testing. This is a huge win for performance and possibly also your internet bandwidth.\nThe amount of time needed to run tests may also be significantly reduced by using UV over pip. Let\u0026rsquo;s say you\u0026rsquo;re installing something like FastAPI with requests, pydantic, starlette, and a few extras. On pip, that could take 8–20 seconds depending on wheel availability and platform. On UV, it might take 1–2 seconds flat. Now repeat that for every environment you want to test against. You can see this can quickly add up to a lot of time saved. It might be the difference between your tests taking 5 minutes, or 30 seconds, especially if your project has a lot of dependencies (ie. if you\u0026rsquo;re using a framework).\nConfiguring Nox to use UV is fairly straightforward. Luckily, the cookbook in the Nox docs includes a section on the best practices to do this.\nHere is the code (slightly modified) from that section:\nimport nox @nox.session( venv_backend=\u0026#34;uv\u0026#34;, python=[\u0026#34;3.10\u0026#34;, \u0026#34;3.11\u0026#34;, \u0026#34;3.12\u0026#34;], ) def tests(session: nox.Session) -\u0026gt; None: session.run_install( \u0026#34;uv\u0026#34;, \u0026#34;sync\u0026#34;, \u0026#34;--quiet\u0026#34;, f\u0026#34;--python={session.virtualenv.location}\u0026#34;, env={\u0026#34;UV_PROJECT_ENVIRONMENT\u0026#34;: session.virtualenv.location}, external=True, ) # Then run your tests: session.run(\u0026#34;mypy\u0026#34;, \u0026#34;src\u0026#34;) session.run(\u0026#34;pytest\u0026#34;, \u0026#34;tests\u0026#34;, \u0026#34;-vvv\u0026#34;) There\u0026rsquo;s two lines in the above code that are particularly important for making this work, which may not be obvious from skimming the Nox documentation (but are shown in the cookbook example). The lines are:\nf\u0026#34;--python={session.virtualenv.location}\u0026#34;, env={\u0026#34;UV_PROJECT_ENVIRONMENT\u0026#34;: session.virtualenv.location}, Together, these two lines tell UV to create the new environment in the location specified by Nox, and then use the Python interpreter from that environment. Without these lines, when Nox creates an environment for the session then UV would create it in the default location and overwrite your existing .venv folder (wherever that may be). This would cause your local development environment to be changed every time you run your tests, which is probably not what you want. You can read more about these options in the UV documentation:\nProject Environment Path\nUV_PYTHON env variable\nThe above example is all you need to get started. Place the example in a file called noxfile.py in your project root, and you can now run the nox command in your terminal to automatically run MyPy and Pytest against Pythons 3.10, 3.11, and 3.12, fully taking advantage of your existing UV cache to install the environments. It\u0026rsquo;s fast and it\u0026rsquo;s reproducible. You can drop this noxfile.py into any project and you\u0026rsquo;re off to the races. It\u0026rsquo;s also pretty convenient to have one consistent nox command across all your Python projects.\nUsing Nox Parametrized Sessions # What if you also want to test against numerous framework versions? For example, if you\u0026rsquo;re a Django developer, you might want to test against Django 3.2, 4.1, and 5.0. Nox makes this easy with parametrized sessions. You can define a session that takes parameters and then run it with different arguments. Since we set up the sessions using Python, it\u0026rsquo;s trivial to specify exactly what versions we want to test against. Here\u0026rsquo;s an example of how you can do this:\nframework = \u0026#34;django\u0026#34; VERSIONS = [3.2, 4.1, 5.0] @nox.session( venv_backend=\u0026#34;uv\u0026#34;, python=PYTHON_VERSIONS, ) @nox.parametrize(\u0026#34;version\u0026#34;, VERSIONS) def tests(session: nox.Session, version: int) -\u0026gt; None: session.run_install( \u0026#34;uv\u0026#34;, \u0026#34;sync\u0026#34;, \u0026#34;--quiet\u0026#34;, f\u0026#34;--python={session.virtualenv.location}\u0026#34;, env={\u0026#34;UV_PROJECT_ENVIRONMENT\u0026#34;: session.virtualenv.location}, external=True, ) major, minor = str(version).split(\u0026#34;.\u0026#34;) next_minor = f\u0026#34;{major}.{int(minor)+1}\u0026#34; session.run_install( \u0026#34;uv\u0026#34;, \u0026#34;pip\u0026#34;, \u0026#34;install\u0026#34;, f\u0026#34;{framework}\u0026gt;={version},\u0026lt;{next_minor}.0\u0026#34;, external=True, ) # Run your tests here In this example we define a list of Django versions that we want to test against. We then use the @nox.parametrize decorator to create a parametrized session that will run the tests for each version in the list. The version parameter is passed to the session function, allowing us to install the specific version of Django for each run. Then this line:\nf\u0026#34;{framework}\u0026gt;={version},\u0026lt;{next_minor}.0\u0026#34;, \u0026hellip;ensures that it grabs the latest patch for the specified minor version of Django (For example for version 3.2 this would result in Django\u0026gt;=3.2,\u0026lt;3.3.0).\nYou can start to imagine how easy it would be to re-use this file almost exactly between projects if you already manage all of them with UV. Just change the framework variable to the name of your framework, and the VERSIONS list to the versions you want to test against, and everything else remains the same.\nSee the Nox docs on parametrized sessions for more information.\nUsing Nox and UV in GitHub Actions CI # Both Nox and UV provide official Github actions that you can use to run your tests in a workflow. This means that you can use the same noxfile.py to run your tests locally and in your CI/CD pipeline. Behold the simplicity of the following workflow file:\n# .github/workflows/ci-checks.yml name: CI Checks on: pull_request: branches: - main jobs: test: runs-on: ubuntu-latest steps: - name: Checkout code uses: actions/checkout@v4 - name: Setup uv uses: astral-sh/setup-uv@v6 with: enable-cache: true - name: Setup Nox uses: wntrblm/nox@2025.05.01 - name: Run Nox sessions run: nox That\u0026rsquo;s it. You can see the official astral-sh/setup-uv and wntrblm/nox Github actions being used (wntrblm/nox seems to use the repository itself as the action). It checks out your code, sets up UV, sets up Nox, and then runs everything you\u0026rsquo;ve defined in your noxfile. Nox will handle the installation of all the Python versions that it needs to test against. The enable-cache: true option in the \u0026lsquo;setup-uv\u0026rsquo; step ensures that the UV cache is used, making the process much faster.\nDoing this same thing with Tox in CI is a bit more complicated. There is no official support for Github actions the same way that Nox has, and it requires you to set up a matrix of jobs to test against multiple Python versions. There\u0026rsquo;s various solutions to try to make this easier such as the tox-gh plugin. But none of them are as simple as the above Nox setup. With Nox, you configure everything in your noxfile, making it easy to re-use the above workflow across all your Python projects. You only need to worry about changing the noxfile to suit each project, while the CI workflow remains the same.\nConclusion # This setup is a game-changer for a few reasons:\nCopy-Paste Simplicity: Two files, minimal config, and you\u0026rsquo;re done. Port it to any Python project in minutes. UV\u0026rsquo;s Speed: UV is much faster than pip for dependency resolution and installation. My CI runs take seconds even when testing numerous Python versions, and local testing is so fast that running it often is no issue. I\u0026rsquo;ve even started using Nox as the testing interface for terminal coding agents, and it works surprisingly well. Nox\u0026rsquo;s Flexibility: Testing multiple Python versions and framework versions is a breeze with Nox\u0026rsquo;s parametrized sessions. With UV becoming more popular every day, there\u0026rsquo;s going to be more people looking for more ways to use it in CI effectively. If you already use UV for managing your project then it`s only natural to want to look for solutions to this. Until recently, this has generally been a headache to achieve with traditional tooling. But now, by leveraging how UV and Nox have a practically symbiotic relationship, this process is so much simpler and faster that I don\u0026rsquo;t think I\u0026rsquo;ll ever have reason to use Tox again. I believe anyone who is a fan of UV will feel the same way after seeing it in action for themselves.\nExternal Links:\nNox Documentation UV Documentation ","date":"6 August 2025","externalUrl":null,"permalink":"/posts/python-testing-with-nox-and-uv/","section":"Articles","summary":"","title":"Python testing with UV and Nox: A perfect pairing","type":"posts"},{"content":"At my place of employment, I was lucky to acquire an old and monstrous computer case that was being thrown in the trash.\nThe computer itself had no value - it was some ancient server from 20 years ago. However, it immediately drew my eyes because of the case. I\u0026rsquo;ve been into refurbishing computers for basically my entire life, so I have a good sense of what parts can be valuable. There was something quite peculiar about this case - It had a 4-drive HDD bay built into it.\nLeft: The PC Case (the HDD bay is already removed here). Right: Front panel of case removed, revealing the bay\nDeconstruction # I did not yet know what it was or if I could use it, but I knew that I had to have it. After getting it home and taking the case apart, I realized that I could slide out the entire HDD bay:\nLeft: Sliding out the bay. Right: Bay removed from case.\nMight this somehow be useful? I still didn\u0026rsquo;t know what I was dealing with. So I started taking photos of the PCB and microchips, hoping that I could get some info on the company and what type of bay I had on my hands.\nLeft: Inside of the bay. Right: Megawin chip closeup\nI eventually learned, through a bit of research, that Chenbro is a respected manufacturer of server equipment, and Megawin makes normal SATA controllers. This is good news - it\u0026rsquo;s verification that all I need is a way to connect it to my computer, and it should work perfectly. Furthermore, I should be able to set up some RAID, as well.\nThe back has an odd connector, and it came with a cable I had never seen before.\nLeft: Back of the bay. Right: Stock photo of the cable (easier to see the detail)\nAfter a bunch of googling, I realized that what I was looking at is called \u0026ldquo;SAS\u0026rdquo;, or Serial-Attached SCSI. Without boring you with details, just know these are the industry standard for connecting a hard drive bay to a server, generally through some kind of PCI-e card. There\u0026rsquo;s several types of SAS - the one on this bay is called SFF-8087. Luckily, I have the cable that came with the bay. So all I need is four SATA ports. That\u0026rsquo;s easy enough. Granted, the cable will need to run from the bay to inside the computer, but I can work with that. (There might be a way to avoid this with adapters, but I don\u0026rsquo;t know for sure, and I didn\u0026rsquo;t want to get sidetracked.)\nPurchasing required parts # Now, the SAS to SATA cable is not that long, so I want these SATA ports to be near the back of my PC. This means plugging them directly into the motherboard is not an option (And besides, there\u0026rsquo;s not enough SATA ports on the motherboard). Thus, I\u0026rsquo;ll have to make an expense to make this work: A PCI-e SATA expansion card. I\u0026rsquo;d never dabbled in RAID before, so I was genuinely not sure if it\u0026rsquo;s better to buy a RAID controller or if I should do software RAID. After a few hours of digging into this subject, I learned that RAID controller cards for consumers are generally being phased out in favor of software RAID (But not so much in datacenters, where they are still prevalent). Nowadays, the CPU in your home PC is so fast that any kind of consumer grade RAID controller card is not going to give you any improvement in performance. It\u0026rsquo;s better to just let the CPU handle it, and that\u0026rsquo;s especially true if you are going to be using a Linux-based NAS OS that comes with a good software RAID implementation.\nThis is great news for the budget-conscious person. This means that you actually want to avoid purchasing a card with a built-in RAID controller. That suits us since they\u0026rsquo;re far more expensive. A nice passive card goes for about 30 bucks on Amazon. I purchased this one here: Amazon link (Not an affiliate link). There\u0026rsquo;s numerous no-name brands but many seem to use the same ASMedia chipset, which is well known and widely supported. So that\u0026rsquo;s reassuring.\nNext I need a computer. I have some spare, old SFF PCs in my house, so my ultimate goal through all of this was to set up one of those fancy \u0026ldquo;Home Lab\u0026rdquo; servers that I\u0026rsquo;d heard so much stuff about. People also sometimes use mini PCs or Raspberry Pis for this. In my case, a skinny office tower with an i7-4770 and 16GB of ram that\u0026rsquo;s been sitting in my closet shall finally be put to good use. (If you don\u0026rsquo;t have something like this, they usually go for about 100 bucks on local used marketplaces). I figured that if I am going to have an external NAS array, then I should do it properly and have a dedicated NAS server. Then I could store all my data like a real professional, without needing to buy a fancy 500 dollar array with a built-in computer.\nConstruction time # I ended up going with TrueNAS, and I do not regret that decision. The details of that will be for another article. The important information is that I installed TrueNAS on the PC, I put the SATA expansion card in, and it worked automatically with no issues. TrueNAS seemed to come with the right drivers for the ASMedia chipset.1 I then plugged each of the four SATA jacks from the bay\u0026rsquo;s SAS cable into the card, tested out a few hard drives, and it worked. We\u0026rsquo;re off to the races now. Time to start putting it all together.\nLeft: Wood added successfully. Right: The card installed in the PC.\nSince I\u0026rsquo;m converting this into an external bay, that means it needs some way to power itself. I\u0026rsquo;ve got just the thing - a PSU that I ripped out of a busted AiO PC. This has been sitting in my closet a while. I knew it would come in handy some day!\nLeft: This PSU has finally found its purpose. Right: I swear this is perfectly safe\nAbout the above right-side photo: Since I\u0026rsquo;m using a dedicated PSU for the bay, I need a way to turn it on. Computer PSUs can be turned on manually by shorting 2 wires (green and black, 4th and 5th from bottom right with clip facing you). This can be achieved easily with a paperclip. Usually this is only done for testing power power supplies, but I don\u0026rsquo;t need to turn this on and off. Once it\u0026rsquo;s on, it\u0026rsquo;s meant to stay on 24/7. I will eventually be purchasing some wires and buttons to do this better. But for now, this paperclip is jammed in nice and tight. (There\u0026rsquo;s no current running through it, by the way, it\u0026rsquo;s just a control signal. So it\u0026rsquo;s not dangerous even though it looks janky.)\nI also knew that I needed some cooling. When it was inside the old server case, the NAS bay had its own fan. With the wood panels on the side, the box is gonna be trapping all the heat inside. But it is designed for air to pass over the drives, and there\u0026rsquo;s vents on the front panel. There\u0026rsquo;s also a fan header on the back of the bay. So I needed to improvise a bit. Turns out, it\u0026rsquo;s nothing that a couple well-placed zip-ties cannot solve (Note the SAS cable has to go up under the fan to plug in.) I tested it with the fan turned off later on and it made an enormous difference - Hard drive temps of 30C with the fan, and 60C without it. That small bit of air passing over the drives makes a huge difference. Especially with the wooden panels, the bay traps all the heat inside, so the fan is extra important here.\nLeft: Zip-tying the fan onto the back. The fan is plugged into a header on the bay. Right: The lights are what sell it\nThe final stage is to get some hard drives hooked up. I happened to have a bunch of HDDs in my spare parts (among many other things\u0026hellip; all from refurbishing old computers). I think it doesn\u0026rsquo;t look terrible once its running with the LEDs lit up. I\u0026rsquo;ll do something about that power cable eventually but it\u0026rsquo;s fine for now.\nIt should be noted, HDDs can be had on used stuff marketplaces for very cheap, often 10 or 15 bucks each, and I have acquired several that way as well. They work fine. Another way to get drives is bulk / lot sales on Ebay. However you choose to acquire them, just know that hard drives, like most machines, will usually keep running if they\u0026rsquo;ve been running for the last 10 years or so. The odds are not very high that it\u0026rsquo;s suddenly gonna crap out on you after you buy it. However, there is always a chance that it will die. That\u0026rsquo;s part of the price you pay for getting used / salvaged stuff for little or no money. But of course this works both ways. If you\u0026rsquo;re getting it for very cheap, then it\u0026rsquo;s not a big deal if it dies on you. That\u0026rsquo;s what the RAID array solves! If one of them dies, you have data redundancy. Just pop the dead drive out of the bay, stick in a new drive of equal size, and TrueNAS will automatically handle the rest.\nAt long last, I get to boot up and try out TrueNAS. Here in my setup you can see I\u0026rsquo;ve got two 1TB drives in a RAID 1 setup (mirroring) as \u0026lsquo;pool1\u0026rsquo; (the data pool), and the other two drives, \u0026lsquo;games1\u0026rsquo;, and \u0026lsquo;games2\u0026rsquo;, just store my Steam games so they\u0026rsquo;re not using RAID.\n*TrueNAS up and running! (Photo taken after I've been using it a while)* At last, my server is working. If you\u0026rsquo;re wondering about the whole Steam games being on the NAS array - that will be the topic of another article. (I will link that here when I finish it). For now, I hope you enjoyed reading this and maybe learned something from it.\n(It must be noted - when I tested this card in my windows 10 PC, it did not work perfectly. It could only connect 2 HDDs at a time. I attempted to download drivers but that didn\u0026rsquo;t seem to solve the issue. However, when used in my other computer running TrueNAS, it immediately worked perfectly without any additional drivers. So take that as you will. I didn\u0026rsquo;t test the card extensively in other computers, and perhaps Linux support is just better. The Amazon comments seem to suggest a few others had a similar problem.)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"21 February 2025","externalUrl":null,"permalink":"/posts/building-a-home-nas/","section":"Articles","summary":"","title":"Building a home NAS array with salvaged parts","type":"posts"},{"content":"","externalUrl":null,"permalink":"/tags/ascii-art/","section":"Tags","summary":"","title":"Ascii-Art","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":"https://www.github.com/edward-jazzhands/cloctui","permalink":"/utilities/cloctui/","section":"Utilities","summary":"A terminal UI for the famous \u0026lsquo;CLOC\u0026rsquo; command-line tool (Count Lines of Code).","title":"CLOCTUI","type":"utilities"},{"content":"","externalUrl":"https://www.github.com/edward-jazzhands/ezpubsub","permalink":"/python-libraries/ezpubsub/","section":"Python Libraries","summary":"An ultra simple, modern pub/sub library and blinker alternative for Python.","title":"EZPubSub","type":"python-libraries"},{"content":"","externalUrl":null,"permalink":"/tags/pyfiglet/","section":"Tags","summary":"","title":"Pyfiglet","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":" by Edward Jazzhands ","externalUrl":null,"permalink":"/python-libraries/","section":"Python Libraries","summary":"","title":"Python Libraries","type":"python-libraries"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/terminal/","section":"Tags","summary":"","title":"Terminal","type":"tags"},{"content":"","externalUrl":null,"permalink":"/tags/textual/","section":"Tags","summary":"","title":"Textual","type":"tags"},{"content":" by Edward Jazzhands The following libraries are all component/widget plugins for Textual , which is a popular Python framework for building terminal user interfaces.\nThe documentation for all these libraries can also be found here:\nLibraries Documentation\n","externalUrl":null,"permalink":"/textual-libraries/","section":"Textual Libraries","summary":"","title":"Textual Libraries","type":"textual-libraries"},{"content":"","externalUrl":null,"permalink":"/tags/tui/","section":"Tags","summary":"","title":"Tui","type":"tags"},{"content":" by Edward Jazzhands ","externalUrl":null,"permalink":"/utilities/","section":"Utilities","summary":"","title":"Utilities","type":"utilities"}]